{
 "cells": [
  {
   "cell_type": "markdown",
   "id": "ae6260c9",
   "metadata": {},
   "source": [
    "# Computer Lab - Semester 3"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "c3bc623d",
   "metadata": {},
   "source": [
    "## Solution of ODE"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "4acae2d3",
   "metadata": {},
   "source": [
    "#### Euler's Method\n",
    "\n",
    "Any equation which involves derivative of a function is called a **differential equation**. Order of the differential equation is defined by the order of the derivative of the function present in the differential equation. A first order linear differential equation is represented by\n",
    "\n",
    "\\begin{equation}\n",
    "\\frac{dy}{dx}=f(x,y(x))\n",
    "\\end{equation}\n",
    "\n",
    "To solve this type of equation numerically, we are given an initial condition, i.e. the value of the function at the initial point. If $x=a$ is the starting point, then we must get the value $y(a)$ at $x=a$. Let $y(a)=c$. Geometrically, it is quite obvious that the function $y(x)$ must pass through $(a,c)$. Therefore, the equation of tangent line drawn at the point (a,c) in xy coordinate plane can be written as -\n",
    "\n",
    "\\begin{align}\n",
    "y - c = \\frac{dy}{dx}\\mid_{(a,c)}(x - a)\n",
    "\\end{align}\n",
    "\n",
    "Now, $\\frac{dy}{dx}\\mid_{(a,c)}=f(a,c)$. Setting, $x-a=h$ as step size or distance between two neighbouring points, we can write the above equation as\n",
    "\n",
    "\\begin{align}\n",
    "y(a+h) \\approx c + f(a,c)\\cdot h\n",
    "\\end{align}\n",
    "\n",
    "Thus the solution passes through a point which is nearly equal to $(a+h, c+f(a,c)h)$. We now repeat this tangent line approximation with (a,c) with successive points separated by a distance $h$. We must replace $(a,c)$ by $(a+h, c+f(a,c)h)$. Keep repeating this tangent line approximation at successive points $x=a,~a+h,~a+2h,\\cdots,b$, we get the values of $y(x)$ for all the points between $x=a$ to $x=b$.\n",
    "\n",
    "Algebraically, the basic idea can be understood in the following way. From calculas, the derivative of a function at a point is given by\n",
    "\n",
    "\\begin{align}\n",
    "\\frac{dy}{dx} = \\lim_{h\\to 0}\\frac{y(x+h)-y(x)}{h}\n",
    "\\end{align}\n",
    "\n",
    "Here $h>0$ and very small. The above equation can be approximately written as\n",
    "\n",
    "\\begin{align}\n",
    "\\frac{dy}{dx} \\approx \\frac{y(x+h)-y(x)}{h}\n",
    "\\end{align}\n",
    "\n",
    "This equation can be solved for $f(x+h)$ to give\n",
    "\n",
    "\\begin{align}\n",
    "f(x+h) \\approx y(x) + h\\cdot f(x,y(x))\n",
    "\\end{align}\n",
    "\n",
    "If we call $y(x+h)$ as \"new value\", then we can write the above equation as\n",
    "\n",
    "\\begin{align}\n",
    "y_{\\text{new}} = y +h \\cdot f(x,y)\n",
    "\\end{align}\n",
    "\n",
    "We can demonstrate the implementation of Euler's method by using the following tabular format -\n",
    "\n",
    "| $x$     | $y$                 | $$h\\cdot f(x,y)$$|\n",
    "| :---    | :---                | :---           |\n",
    "|$a$      | $c$                 | $$h\\cdot f(a,c)$$| \n",
    "|$a+h$    | $$c + h\\cdot f(a,c)$$ | $\\cdots$       |\n",
    "|$a + 2h$ | $\\cdots$            |                | \n",
    "|$\\vdots$ |                     |                |\n",
    "|$b$      | ???                 | X              |\n",
    "\n",
    "The goal is to fill out all the blanks of the table except X entry and find the ??? entry, which is the Eulerâ€™s method approximation for $y(b)$."
   ]
  },
  {
   "cell_type": "markdown",
   "id": "bc1d6a9a",
   "metadata": {},
   "source": [
    "Consider the following ODE\n",
    "\\begin{align}\n",
    "\\frac{dy}{dx}=\\frac{y+x}{y-x},\\hspace{0.5cm}y(0)=1\n",
    "\\end{align}\n",
    "Find the value y at x = 0.6, taking the step size = 0.2."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 42,
   "id": "c7a0c289",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "x         y    \n",
      "------------------\n",
      "0.0    1.000\n",
      "0.2    1.200\n",
      "0.4    1.480\n",
      "0.6    1.828\n",
      "------------------\n"
     ]
    },
    {
     "data": {
      "image/png": "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e7p06RKZ7tWrFw0aNIhliaUStVNSZvYa0BNoaGbZwINAdQB3fy682g3AXHf/usBXGwNvmdmJel9199nRqltE5HS2bdvGWWedRZ06dVi5ciVPPPEEP/7xj0lJSeGnP/1prMsrU3rinohICa1fv56UlBQmTJjA8OHDyc3N5fDhw5x99tmxLq3E4uU+DBGRCs3dGTVqFOPHjwegXbt2jB07ll69egFQs2bNCh0WZ6LAEBE5jezsbN5++20AzIzt27eze/fuyPRvfvMbWpXxmE3xKh4vqxURianc3NzIOE1/+tOfeOGFF9i1axd16tRh6tSphPtUqxwdYYiIFDB37lySkpLYEH740G9/+1tWr15NnTp1AKpsWIACQ0SquK+++opHHnmEf/7znwCkpqZyww03RO6ROP/886vMKacz0SkpEalyvv76a3Jycmjbti01atTgqaeeAuDKK6+kSZMmvPjii7EtME4pMESkyunduzd5eXksXbqUmjVrsmnTJs4666xYlxX3dEpKRCq9119/ncsuu4zjx48DoaHEH3/88chyhUUwCgwRqXS++uorJk2axJ49e4DQOE5169aNXA7bp08frrjiiliWWCEpMESkUsjPz+fQoUMAZGVlMXz4cGbOnAnAgAEDmDt3buRpdlIyCgwRqfCOHTtG27ZteeihhwC45JJLWLFiBUOHDo1tYZWMAkNECjVs2DCSkpLo0KHDaddbtmwZiYmJTJs2LTLvt7/9LSkpKVx00UXcddddlMeYda+99hqjR48GoHr16tx222307Nkzsrxz585V+p6J8qDAEJFC3XrrrcyeffqBofPy8rjnnnvo06dPZN7ixYv58MMPWbVqFatXr2bZsmVl8mzqvLw8Fi3613PTMjIyeOeddyId2b///e/p379/qfcjRVNgiEihevToccZnN/z3f/83N910E0lJSZF5ZsaRI0c4evQoubm5HDt2jMaNG5e4jhNHJxMnTuSqq65i5cqVADz66KMsX76cxETdHRAtCgwRKZGcnBzeeuutbz3z4Xvf+x69evWiadOmNG3alL59+3LRRRcVe/tbt26la9euTJ8eep7aoEGDmDZtWmRbNWvW1CmnKFNgiEiJ/PKXv2TcuHHfesxoZmYm69atIzs7m5ycHN5///3IsBun4+688847/P3vfwegadOm1K9fn4SEBAAaNGjATTfdFBkUUKJPx3IiUiIZGRkMHjwYgN27dzNr1iwSExP57LPP6N69O3Xr1gXg2muv5aOPPuLKK68sdDs7duygcePGmBljxoyhTp069O/fn8TERObNmxe19siZ6QhDREpk8+bNbNmyhS1btjBo0CCeffZZBg4cSIsWLVi4cCHHjx/n2LFjLFy4sMhTUvfeey8pKSnk5uYC8MYbbzBnzpxoNkOKQUcYIlKoIUOGsGDBAnbv3k3z5s15+OGHOXbsGAAjR44s8nuDBg3i/fffp2PHjpgZ/fr1Iz09HYDVq1fzwAMP8Oyzz9KkSRMGDBhAs2bNyM/PB0Ijw0r8itozvc1sEtAf2Onu37qw28x6AtOBzeFZb7r7mPCyfsBfgATgb+4+Nsg+9Uxvkdhyd1auXEn9+vVp1aoV69evp1evXkyZMoWrrroq1uVJIeLlmd4vAv3OsM4/3b1T+HUiLBKAZ4BrgYuBIWZ2cblWKiKlcuKI4dChQ1x22WU88cQTALRv357s7GyFRQUVtVNS7r7IzC4owVe7ApnungVgZlOA64G1ZVieiJSRO+64g23btjFjxgzq1avH9OnTSUv71x+sJ656koon3jq9v2dmn5jZu2aWEp7XDNhaYJ3s8LxCmdkIM8sws4xdu3aVZ60iVVtWFqSk4ImJ7GzUCN+0CQgdRaSmpkZuuOvTp88ZbwCUiiGeOr1XAOe7+yEzuw54G2hT3I24+wRgAoT6MMq0QhEhLy+PJUuW0P3220nYuBHLz+fc3bs51q8fNT77jLvvvjvWJUo5iZsjDHc/6O6Hwp9nAdXNrCGQAyQXWLV5eJ6IRMnBgwfZt28fAEuWLOGKK67ANm6EcF9FAlBj8+bTbEEqg7gJDDNrYuH7/M2sK6Ha9gDLgDZm1tLMagCDgRmxq1Skajhxb8SBAwdISkri6aefBqB79+688cYbeNu2cOIu72rVoF27WJUqURK1U1Jm9hrQE2hoZtnAg0B1AHd/DhgE/NTMjgOHgcEeOgl63MxGAXMI/SEzyd3XRKtukaqoZ8+eJCcn8/LLL1O/fn3Gjx8fuVM7ISGBH/zgB9ClC6Snw4YNobAIP6xIKq+o3YcRC7oPQySYP/7xj3z44YfMmjULgD//+c80aNCA4cOHx7gyibZ4uQ9DROLEvHnzuOGGGyLPkqhXrx4NGzYkLy8PgN/85jcKC/kWBYZIFfD5559z7733sn37dgD279/P+vXryckJXT9y1113MXnyZN0jIaelwBCphI4cOcK0adNYt24dEOq4fvzxx1m+fDkQGu9p3bp1GrtJikWBIVJJbN68mTVrQteD5ObmMmTIEF555RUAOnbsyO7du/m3f/s3AD14SEoknm7cE5FiyMvL48svvyQ5ORl3p2fPnnTu3Jm3336b+vXrs3z5ci6+ODTsmplRv379GFcsFZ0CQ6QCyc3NjTxx7gc/+AHr169n7dq1mBkvvvgiLVq0iKybmpoaqzKlklJgiFQQTz31FA8++CDbtm2jVq1a3HHHHezfvx93x8zo1atXrEuUSk59GCJxavHixXTo0IHMzEwALr30Un7yk5/wzTffANC3b19+9KMfqT9CokaBIRInduzYwdChQ5k/fz4ATZo0oXHjxnz11VcAXHHFFYwfP14jv0rMKDBEYiQ/P5+nnnqKt99+G4D69eszf/58Pv/8cwBatWrFe++9R+fOnWNYpci/qA9DJIqWLl3Ktm3bGDhwINWqVeP555+na9euDBw4kFq1avH555/rFJPELQWGSDk6ePAgK1asoGfPngCMHTuWTz75hOuvvx4zY/HixSdd7qqwkHimU1IiZWzLli2Rp809+uij9O7dmwMHDgDwxBNPsGLFikgw6N4IqUgUGCKllJeXx7FjxwCYOnUqLVu25JNPPgHgJz/5Ce+99x5169YFoGXLlpx99tmxKlWkVBQYEnPDhg0jKSmJDh06FLr8lVdeITU1lY4dO3LZZZdFfhkDzJ49m3bt2tG6dWvGjh0brZIjMjMzadKkCW+99RYAV111FU888QRNmzYF4MILL6RHjx4a1E8qBQWGxNytt97K7Nmzi1zesmVLFi5cyKeffsro0aMZMWIEEPrL/s477+Tdd99l7dq1vPbaa6xdu7Zcaz127Bh9+/Zl/PjxkdpuuOGGyB3WSUlJ3H333TRu3Lhc6xCJBXV6S8z16NGDLVu2FLn8sssui3zu3r072dnZAHz88ce0bt2aVq1aATB48GCmT58eGT+prIwbN45Dhw7xyCOPUL16dc4999zIKaaEhAQmTJhQpvsTiVcKDKlQJk6cyLXXXgtATk4OycnJkWXNmzdn6dKlpd7H/PnzWbhwIQ899BAAGzdu5ODBg5Hlr776aqn3IVIRRe2UlJlNMrOdZra6iOU/NrNVZvapmS02s0sKLNsSnr/SzPTM1Spq/vz5TJw4kXHjxpXpdr/88kueeeaZyNPnFi9ezNNPP82hQ4cA+Nvf/sbUqVPLdJ8iFVE0+zBeBPqdZvlm4Cp37wg8Apx6nN/L3TsV9axZqdxWrVrF7bffzvTp0zn33HMBaNasGVu3bo2sk52dTbNmzc64rby8PBYvXszevXsB+PDDDxk1alTk4UK//OUv2b59e+S0k+6NEAmJWmC4+yJg72mWL3b3feHJJUDzqBQmce+LL77gxhtv5OWXX6Zt27aR+d/97nf57LPP2Lx5M0ePHmXKlCkMGDCg0G0cPHiQXbt2AbB69Wouv/zyyJVN1113HZ999hndunUDoE6dOiQm6mytyKni9f+K4cC7BaYdmGtmDjzv7kX2MprZCGAEcNKzASR+DRkyhAULFrB7926aN2/Oww8/HLmvYeTIkYwZM4Y9e/bws5/9DIDExEQyMjJITEzk6aefpm/fvuTl5TFs2DBSUlIi2z1y5Ai1atXiyJEjnHfeedx5552MGzeO1NRUpk2bxjXXXAOEAqJ169bRb7hIBWMn7kiNys7MLgD+7u6FX3AfWqcX8CxwhbvvCc9r5u45ZpYEzAN+Hj5iOa20tDTPyFCXR1V07bXXUrNmzcjAfs8//zxdunQhLU1nNEVOx8yWF3XqP66OMMwsFfgbcO2JsABw95zw+04zewvoCpwxMKTqeOyxx5g5cyYLFy4EQqeZqlevHll+xx13xKo0kUojbm7cM7MWwJvAf7j7xgLz65hZvROfgT5AoVdaSSWVlQUpKZCYGHrPymLhwoX079+fw4cPA9CgQQOaN2/OkSNHAPj5z3/OyJEjY1m1SKUTzctqXwM+AtqZWbaZDTezkWZ24v/qB4BzgWdPuXy2MfCBmX0CfAy84+5F3xYslU96Or5+PeTlhd7T0zl8+DCZmZl88cUXQGh4kVdeeYVatWrFuFiRyiuqfRjRpj6MimvPnj3cfffd3HzzzfS57jrIy/vXwoQE/NgxXe4qUg5O14cRN6ekpOpxd77++msgNEbTFVdcwWOPPQZAvXr1WLRoUWgYkHbt8Grhf6rVqkG7dgoLkRiIq05vqdz27dvHrl27IvdSXHLJJXTq1InJkydTvXp1LrjggshNeTVq1PjX+FI9e2Lp6bBhA7RrBzNnxqgFIlWbAkPKzZo1a8jKyiI9PR2AgQMHkpuby5IlSwC4/fbbadKkSWT9//mf/yl8Q61awZo15V6viJyeAkPKzIcffsg//vEPHnzwQQCefPJJ3nzzTXbv3o2Z8cADD5z0XIi77rorVqWKSAmoD0NKbP78+QwYMCByaevixYsZN25c5HGk9913HytWrIisf80110SebS0iFY8CQ07r6NGjHD16FIAPPviA9u3bs27dOgAOHTrEpk2b+PLLLwH42c9+xoEDByLPqW7ZsiXnn3++OqhFKgkFhkS4O5s3b2bHjh0AfPrpp5x11lnMmjULCD1Nrl27dpFxntLT01mzZg0XXnghEBqTqeDd1SJSuSgwqrD8/Hzmzp0bOW20Z88eWrVqxUsvvQRA69atufPOOyNPtGvbti3Tp08nNTU1ZjWLSOxUucAYNmwYSUlJdOhQ+PiH7s5dd91F69atSU1NPekc/EsvvUSbNm1o06ZN5JdqRTNx4kRef/11IPSchyFDhvDss88C0LBhQyZPnsyNN94IQO3atXn88ccVECIS4u6V9tWlSxc/1cKFC3358uWekpLyrWXu7u+8847369fP8/Pz/aOPPvKuXbu6u/uePXu8ZcuWvmfPHt+7d6+3bNnS9+7dW+g24sn48eP9nnvuiUx3797d09PTI9MrVqzw/fv3x6I0EYlDQIYX8Tu1yh1h9OjRgwYNGhS5fPr06dxyyy2YGd27d2f//v1s27aNOXPm0Lt3bxo0aMA555xD7969mT07Poa0OnG3NMAf/vAHevToEZnOyspi48bIWI7Mnj2b6dOnR6Y7d+4c6aQWETmdKhcYZ5KTk0NycnJkunnz5uTk5BQ5P9qOHj3K8uXL8fAYYGPHjqVhw4aRK5maNGlC69atyQuPvfTXv/6VN998M/L9+vXr66olESkRBUac27NnD1OmTGH//v1AqB8lLS2NTZs2AXDllVcyevRocnNzgdDd05MmTTrpBjkRkbKgwDhFs2bN2Lp1a2Q6OzubZs2aFTm/rO3cuZM//OEPrF27Fgg9f3rIkCEsXrwYgH79+vH666+TlJQEwOWXX859991HvXr1yrwWEZGCFBinGDBgAJMnT8bdWbJkCfXr16dp06b07duXuXPnsm/fPvbt28fcuXPp27dvqfd38OBBhg4dGulXyMvL44EHHmDp0qUAdO3alRUrVtC7d28AkpOT+eEPf8hZZ51V6n2LiBRHlRtLasiQISxYsIDdu3fTvHlzHn744ciNaCNHjuS6665j1qxZtG7dmu985zu88MILQOiJbqNHj+a73/0uAA888MBpO88Lcne++eYb6tSpQ35+PldffTXXXHMNo0ePpm7dunz00Ud069YNgKZNm7J///5IINSuXZvOnTuX9X8GEZFi0wOUysGJK6suuugiALp160ZycjLTpk0DYPjw4XTt2lXPmRaRuHO6ByhVuSOM8rBu3TrWr1/PDTfcAISOYnJycli1ahUAt91220mXrk6cODEmdYqIlEZU+zDMbJKZ7TSz1UUsNzN7yswyzWyVmV1aYNlQM/ss/Boavaq/bcmSJdx///2RS1ufe+45br75Zo4fPw7A7373O5588snI+iNHjmTIkCGxKFVEpMwEDgwze9vM+ptZaULmRaDfaZZfC7QJv0YAfw3vuwHwINAN6Ao8aGbnlKKOomVlQUoKJCaG3rOy+OCDD0hPT49c2rp8+XIef/xxdu7cCcCvfvUr1q5dG7mUtUePHlx99dXlUp6ISKwU55f/18DrQLaZPWpmbYq7M3dfBOw9zSrXA5PDd6gvAc42s6ZAX2Ceu+91933APE4fPCWXnk7+unWQl4evWwfp6eTm5p40jPewYcM4ePAgjRs3BqBFixYaxltEKr3AgeHuPwaaAo8A3wc2mNkiM7vFzGqXUT3NgK0FprPD84qa/y1mNsLMMswsY9euXcWvYMMGqoVPNZk7bNjANddcw9q1a7n44ouB0JVLGsZbRKqaYp1ecveD7v5Xd+8KdASWA88D28zseTO7qDyKLA53n+Duae6e1qhRo+JvoF07qBb+z1KtWmhaRERK1ultZucROn3UHzgO/C+QDKwys1+Xop6c8HZOaB6eV9T8sjdzJrRvDwkJofeZM8tlNyIiFU1xOr2rm9kgM5sFfA4MBMYDTd19uLtfB9wE3F+KemYAt4SvluoOHHD3bcAcoI+ZnRPu7O4Tnlf2WrWCNWvg+PHQe/jhQSIiVV1x7sPYBhjwKnCvu68qZJ1FwL6iNmBmrwE9gYZmlk3oyqfqAO7+HDALuA7IBL4Bbgsv22tmjwDLwpsa4+6n6zwXEZEyFvhObzP7D2Cqux8p35LKTqzu9BYRqajK5E5vd3+57EoSEZGKRqPViohIIAoMEREJRIEhIiKBKDBERCQQBYaIiASiwBARkUAUGCIiEogCQ0REAlFgiIhIIAoMEREJRIEhIiKBKDBERCQQBYaIiASiwBARkUAUGCIiEogCQ0REAlFgiIhIIFENDDPrZ2YbzCzTzO4tZPl/mdnK8Gujme0vsCyvwLIZ0axbRESK8YjW0jKzBOAZoDeQDSwzsxnuvvbEOu5+d4H1fw50LrCJw+7eKUrliojIKaJ5hNEVyHT3LHc/CkwBrj/N+kOA16JSmYiInFE0A6MZsLXAdHZ43reY2flAS+D9ArNrmVmGmS0xs4FF7cTMRoTXy9i1a1cZlC0iIhC/nd6DgWnunldg3vnungb8O/CkmV1Y2BfdfYK7p7l7WqNGjaJRq4hIlRDNwMgBkgtMNw/PK8xgTjkd5e454fcsYAEn92+IiEg5i2ZgLAPamFlLM6tBKBS+dbWTmbUHzgE+KjDvHDOrGf7cELgcWHvqd0VEpPxE7Sopdz9uZqOAOUACMMnd15jZGCDD3U+Ex2Bgirt7ga9fBDxvZvmEQm5swaurRESk/NnJv5crl7S0NM/IyIh1GSIiFYaZLQ/3F39LvHZ6i4hInFFgiIhIIAoMEREJRIEhIiKBKDBERCQQBYaIiASiwBARkUAUGCIiEogCQ0REAlFgiIhIIAoMEREJRIEhIiKBKDBERCQQBYaIiASiwBARkUAUGCIiEogCQ0REAlFgiIhIIFENDDPrZ2YbzCzTzO4tZPmtZrbLzFaGX7cXWDbUzD4Lv4ZGs24REYHEaO3IzBKAZ4DeQDawzMxmuPvaU1Z93d1HnfLdBsCDQBrgwPLwd/dFoXQRESG6RxhdgUx3z3L3o8AU4PqA3+0LzHP3veGQmAf0K6c6RUSkENEMjGbA1gLT2eF5p7rJzFaZ2TQzSy7mdzGzEWaWYWYZu3btKou6RUSE+Ov0nglc4O6phI4iXiruBtx9grunuXtao0aNyrxAEZGqKpqBkQMkF5huHp4X4e573D03PPk3oEvQ74qISPmKZmAsA9qYWUszqwEMBmYUXMHMmhaYHACsC3+eA/Qxs3PM7BygT3ieiIhESdSuknL342Y2itAv+gRgkruvMbMxQIa7zwDuMrMBwHFgL3Br+Lt7zewRQqEDMMbd90ardhERAXP3WNdQbtLS0jwjIyPWZYiIVBhmttzd0wpbFm+d3iIiEqcUGCIiEogCQ0REAlFgiIhIIAoMEREJRIEhIiKBKDBERCQQBYaIiASiwBARkUAUGCIiEogCQ0REAlFgiIhIIAoMEREJRIEhIiKBKDBERCQQBYaIiASiwBARkUAUGCIiEkhUA8PM+pnZBjPLNLN7C1n+n2a21sxWmdl7ZnZ+gWV5ZrYy/JoRzbpFRAQSo7UjM0sAngF6A9nAMjOb4e5rC6z2f0Cau39jZj8FxgM/Ci877O6dolWviIicLJpHGF2BTHfPcvejwBTg+oIruPt8d/8mPLkEaB7F+kRE5DSiGRjNgK0FprPD84oyHHi3wHQtM8swsyVmNrAc6hMRkdOI2imp4jCzm4E04KoCs8939xwzawW8b2afuvumQr47AhgB0KJFi6jUKyJSFUTzCCMHSC4w3Tw87yRm9n3g98AAd889Md/dc8LvWcACoHNhO3H3Ce6e5u5pjRo1KrvqRUSquGgGxjKgjZm1NLMawGDgpKudzKwz8DyhsNhZYP45ZlYz/LkhcDlQsLNcRETKWdROSbn7cTMbBcwBEoBJ7r7GzMYAGe4+A/gzUBeYamYAX7j7AOAi4HkzyycUcmNPubpKRETKmbl7rGsoN2lpaZ6RkRHrMkREKgwzW+7uaYUt053eIiISiAJDREQCUWCIiEggCgwREQlEgSEiIoEoMEREJBAFhoiIBKLAEBGRQBQYIiISiAJDREQCUWCIiEggCgwREQlEgSEiIoEoMEREJBAFhoiIBKLAEBGRQBQYIiISiAJDREQCUWCIiEggUQ0MM+tnZhvMLNPM7i1keU0zez28fKmZXVBg2e/C8zeYWd9o1i0iIlEMDDNLAJ4BrgUuBoaY2cWnrDYc2OfurYH/AsaFv3sxMBhIAfoBz4a3JyIiURLNI4yuQKa7Z7n7UWAKcP0p61wPvBT+PA24xswsPH+Ku+e6+2YgM7w9ERGJksQo7qsZsLXAdDbQrah13P24mR0Azg3PX3LKd5sVthMzGwGMCE8eMrMNJay3IbC7hN+NN5WlLZWlHaC2xKPK0g4oXVvOL2pBNAMjKtx9AjChtNsxswx3TyuDkmKusrSlsrQD1JZ4VFnaAeXXlmieksoBkgtMNw/PK3QdM0sE6gN7An5XRETKUTQDYxnQxsxamlkNQp3YM05ZZwYwNPx5EPC+u3t4/uDwVVQtgTbAx1GqW0REiOIpqXCfxChgDpAATHL3NWY2Bshw9xnAROBlM8sE9hIKFcLrvQGsBY4Dd7p7XjmXXOrTWnGksrSlsrQD1JZ4VFnaAeXUFgv9AS8iInJ6utNbREQCUWCIiEggVT4wSjNcSTwJ0I4eZrbCzI6b2aBY1BhUgLb8p5mtNbNVZvaemRV53XisBWjLSDP71MxWmtkHhYx+EBfO1I4C691kZm5mcXt5aoCfya1mtiv8M1lpZrfHos4ggvxczOyH4f9f1pjZq6XaobtX2RehzvdNQCugBvAJcPEp6/wMeC78eTDweqzrLmE7LgBSgcnAoFjXXMq29AK+E/7803j8mRSjLWcV+DwAmB3rukvSjvB69YBFhG6yTYt13aX4mdwKPB3rWsuoLW2A/wPOCU8nlWafVf0IozTDlcSTM7bD3be4+yogPxYFFkOQtsx392/Ck0sI3ZcTj4K05WCByTpAPF6FEuT/E4BHCI3/diSaxRVT0LZUBEHa8hPgGXffB+DuO0uzw6oeGIUNV3LqkCMnDVcCnBiuJJ4EaUdFUdy2DAfeLdeKSi5QW8zsTjPbBIwH7opSbcVxxnaY2aVAsru/E83CSiDov6+bwqc8p5lZciHL40GQtrQF2prZh2a2xMz6lWaHVT0wpAIzs5uBNODPsa6lNNz9GXe/ELgHuD/W9RSXmVUDngB+FetayshM4AJ3TwXm8a8zDBVRIqHTUj2BIcD/M7OzS7qxqh4YpRmuJJ5UpqFTArXFzL4P/B4Y4O65UaqtuIr7c5kCDCzPgkroTO2oB3QAFpjZFqA7MCNOO77P+DNx9z0F/k39DegSpdqKK8i/r2xghrsf89BI3xsJBUjJxLrjJsadRolAFtCSf3UapZyyzp2c3On9RqzrLkk7Cqz7IvHd6R3kZ9KZUGdfm1jXWwZtaVPgczqhUQ9iXntJ/32F119A/HZ6B/mZNC3w+QZgSazrLkVb+gEvhT83JHQK69wS7zPWjY71C7iOUOpuAn4fnjeG0F+uALWAqYSewfEx0CrWNZewHd8l9NfG14SOkNbEuuZStOUfwA5gZfg1I9Y1l6ItfwHWhNsx/3S/iOO5HaesG7eBEfBn8qfwz+ST8M+kfaxrLkVbjNDpwrXAp8Dg0uxPQ4OIiEggVb0PQ0REAlJgiIhIIAoMEREJRIEhIiKBKDBERCQQBYaIiASiwBARkUAUGCIiEogCQyQKzKyRmW0zswcLzEs1syNm9oNY1iYSlO70FokSM+tLaCTUqwgNBZIBfOzut8WyLpGgFBgiUWRmTxJ6st5C4Eqgk7sfimlRIgEpMESiyMxqEhrUrg1wmbsvjXFJIoGpD0Mkui4g9AwDJ/QsZpEKQ0cYIlFiZtUJPYN8I7AUeBC4xN2/iGlhIgEpMESixMzGAv8OpBJ6Nvy7hJ63crW758eyNpEgdEpKJArM7CpCz7y+xd33e+gvtVuBiwk9y1sk7ukIQ0REAtERhoiIBKLAEBGRQBQYIiISiAJDREQCUWCIiEggCgwREQlEgSEiIoEoMEREJJD/D521Ro5mdab9AAAAAElFTkSuQmCC\n",
      "text/plain": [
       "<Figure size 432x288 with 1 Axes>"
      ]
     },
     "metadata": {
      "needs_background": "light"
     },
     "output_type": "display_data"
    }
   ],
   "source": [
    "import numpy as np\n",
    "import matplotlib.pyplot as plt\n",
    "\n",
    "# Discretize the independent variable 'x'\n",
    "x_init, x_final, step = 0, 0.6, 0.2\n",
    "x = np.arange(x_init, x_final+step, step)\n",
    "\n",
    "#Create array for unknown or dependent variable\n",
    "y = np.zeros(len(x))\n",
    "y[0] = 1\n",
    "\n",
    "# Define helper functions\n",
    "def f(x,y):\n",
    "\tslope = (y+x)/(y-x)\n",
    "\treturn slope\n",
    "\n",
    "def Euler(x, y, h):\n",
    "\ty_new = y + h*f(x, y)\n",
    "\treturn y_new\n",
    "\n",
    "# use recursive relation to find the 'y' values at different grid points of 'x'\n",
    "h = step\n",
    "for i in range(len(x)-1):\n",
    "    y[i+1] = Euler(x[i], y[i], h)\n",
    "\n",
    "# Tabulating the result\n",
    "y = y.reshape([-1,1])\n",
    "x = x.reshape([-1,1])\n",
    "\n",
    "val = np.hstack([x, y])\n",
    "\n",
    "print(\"{0:10s}{1:5s}\".format('x','y'))\n",
    "print('------------------')\n",
    "for i in range(len(val[:,0])):\n",
    "    print(\"{0:0.1f} {1:8.3f}\".format(val[:,0][i], val[:,1][i]))\n",
    "print('------------------')\n",
    "\n",
    "# Graphical demonstration\n",
    "plt.plot(x, y, ls=':', color='k', markersize=4)\n",
    "plt.plot(x, y, 'ro', markersize=4)\n",
    "plt.xlabel('x', fontsize=14)\n",
    "plt.ylabel('y', fontsize=14)\n",
    "\n",
    "# Displaying values next to point\n",
    "for i in range(len(y)):\n",
    "\tplt.text(x[i], y[i]+0.05, \"%0.2f\" %y[i], ha=\"center\")\n",
    "plt.ylim(0, 2)\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "5e4066ec",
   "metadata": {},
   "source": [
    "#### Modified Euler method\n",
    "\n",
    "The biggest shortcoming in Euler's method is that the derivative or slope estimated at the begining of the interval is applied through out the interval which generally, is not the case. As a modification, the derivative is estimated at the begining and at the end of the interval and average of the two values is used to estimate the value at the next stage. So, if we consider an interval between $x$ and $x+h$ and the value of $y(x)$ is known, then to estimate the value at $x+h$, we calculate the slope at $x$, which is $\\frac{dy}{dx}$ and estimate $y(x+h)$ which is given by\n",
    "\n",
    "\\begin{align}\n",
    "y(x+h) = y(x) + h\\cdot f(x,y)\n",
    "\\end{align}\n",
    "\n",
    "Let us call this value of $y(x+h)$ as predicted value of $y$ or $y_p$. Using the value of $y_p$, we estimate the slope at $x+h$ which is given by $f(x+h, y_p)$. Let us call\n",
    "\n",
    "\\begin{align}\n",
    "&k_1 = f(x,y)\\\\\n",
    "&k_2 = f(x+h, y_p)\n",
    "\\end{align}\n",
    "\n",
    "We use the average of $k_1$ and $k_2$ to estimate the value at $x+h$, given by\n",
    "\n",
    "\\begin{align}\n",
    "y(x+h) = y(x) + \\left( \\frac{k_1+k_2}{2}\\right) \\cdot h\n",
    "\\end{align}\n",
    "\n",
    "This value of $y(x+h)$ is known as *corrector* value or $y_c$.\n",
    "\n",
    "The previous problem can be solved by modified Euler method by modifying the code in the Euler function. The code snippet is given below."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 45,
   "id": "350d43f7",
   "metadata": {},
   "outputs": [],
   "source": [
    "def modEuler(x, y, h):\n",
    "    k1 = f(x, y)\n",
    "    y_p = y + k1*h\n",
    "    k2 = f(x+h, y_p)\n",
    "    y_c = y + h*(k1+k2)/2\n",
    "    return y_c"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "e78b75cd",
   "metadata": {},
   "source": [
    "#### Runge Kutta Method of Second Order\n",
    "\n",
    "In this method. we estimate the slope at the middle of the interval $(x, x+h)$. Let $f(x, y)$ be the slope at $x$ and the slope at $x+h/2$ be $f(x+h/2, y+k1/2)$. Considering this slope is better estimate for the interval, we use it for the whole interval to estimate the value at $x+h$. This can be shown below -\n",
    "\\begin{align}\n",
    "&k_1 = f(x,y) \\nonumber\\\\\n",
    "&k_2 = (x+\\frac{h}{2}, y + \\frac{h}{2}k_1)\\nonumber\\\\\n",
    "&y(x+h) = y(x) + h\\cdot k_2\n",
    "\\end{align}"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "176b20d9",
   "metadata": {},
   "source": [
    "Solve the differential equation\n",
    "\\begin{equation}\n",
    "\\frac{dy}{dt}=t+y\n",
    "\\end{equation}\n",
    "\n",
    "with the initial condition $y(0)=1$, using fourth order Runge-Kutta method from $t=0$ to $t=0.4$ taking $h=0.1$."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 51,
   "id": "312f07a0",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "t         y    \n",
      "------------------\n",
      "0.0    1.000\n",
      "0.1    1.120\n",
      "0.2    1.264\n",
      "0.3    1.435\n",
      "0.4    1.636\n",
      "------------------\n"
     ]
    }
   ],
   "source": [
    "def model(t, y):\n",
    "    return t + y\n",
    "\n",
    "def rk2Func(x, y, h):\n",
    "    k1 = model(x, y)\n",
    "    k2 = model(x+h, y+k1*h)\n",
    "    y_new = y + k2*h\n",
    "    return y_new\n",
    "\n",
    "t = np.arange(0, 0.4 + 0.1, 0.1)\n",
    "y = np.zeros(len(t))\n",
    "y[0] = 1\n",
    "h = 0.1\n",
    "\n",
    "for i in range(len(t)-1):\n",
    "    y[i+1] = rk2Func(t[i], y[i], h)\n",
    "    \n",
    "# Tabulating the result\n",
    "y = y.reshape([-1,1])\n",
    "t = t.reshape([-1,1])\n",
    "\n",
    "val = np.hstack([t, y])\n",
    "\n",
    "print(\"{0:10s}{1:5s}\".format('t','y'))\n",
    "print('------------------')\n",
    "for i in range(len(val[:,0])):\n",
    "    print(\"{0:0.1f} {1:8.3f}\".format(val[:,0][i], val[:,1][i]))\n",
    "print('------------------')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "8433aeb2",
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.7.6"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
